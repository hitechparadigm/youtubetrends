/**\n * YouTube Automation Platform - Service Wrapper\n * \n * Simple wrapper to add error handling to existing service calls\n * without modifying existing code extensively.\n */\n\nconst ErrorHandler = require('./ErrorHandler');\n\nclass ServiceWrapper {\n    constructor(options = {}) {\n        this.errorHandler = options.errorHandler || ErrorHandler;\n        this.enableMetrics = options.enableMetrics !== false;\n        \n        // Simple metrics (in-memory, no external dependencies)\n        this.metrics = {\n            calls: 0,\n            successes: 0,\n            failures: 0,\n            lastReset: Date.now()\n        };\n    }\n\n    /**\n     * Wrap AI service calls with error handling\n     */\n    async callAIService(serviceName, primaryFn, fallbackFn = null) {\n        this.metrics.calls++;\n        \n        try {\n            const result = await this.errorHandler.handleAIServiceCall(\n                primaryFn,\n                serviceName,\n                fallbackFn\n            );\n            \n            this.metrics.successes++;\n            return result;\n            \n        } catch (error) {\n            this.metrics.failures++;\n            \n            // Add service context to error\n            error.service = serviceName;\n            error.timestamp = new Date().toISOString();\n            \n            throw error;\n        }\n    }\n\n    /**\n     * Wrap configuration calls\n     */\n    async callConfigService(fn, context = {}) {\n        return this.errorHandler.executeWithRetry(fn, {\n            service: 'configuration',\n            ...context\n        });\n    }\n\n    /**\n     * Wrap external API calls\n     */\n    async callExternalAPI(apiName, fn, options = {}) {\n        const serviceName = `external_api_${apiName}`;\n        \n        return this.errorHandler.executeWithRetry(fn, {\n            service: serviceName,\n            ...options\n        });\n    }\n\n    /**\n     * Get simple service metrics\n     */\n    getMetrics() {\n        const uptime = Date.now() - this.metrics.lastReset;\n        const successRate = this.metrics.calls > 0 ? \n            (this.metrics.successes / this.metrics.calls) * 100 : 0;\n        \n        return {\n            calls: this.metrics.calls,\n            successes: this.metrics.successes,\n            failures: this.metrics.failures,\n            successRate: Math.round(successRate * 100) / 100,\n            uptime: Math.round(uptime / 1000), // seconds\n            errorSummary: this.errorHandler.getErrorSummary()\n        };\n    }\n\n    /**\n     * Reset metrics (useful for testing)\n     */\n    resetMetrics() {\n        this.metrics = {\n            calls: 0,\n            successes: 0,\n            failures: 0,\n            lastReset: Date.now()\n        };\n    }\n\n    /**\n     * Create a wrapped version of a function\n     */\n    wrapFunction(fn, serviceName) {\n        return this.errorHandler.wrap(fn, serviceName);\n    }\n\n    /**\n     * Handle common error scenarios with fallbacks\n     */\n    async withFallback(primaryFn, fallbackFn, serviceName = 'unknown') {\n        try {\n            return await this.errorHandler.executeWithRetry(primaryFn, { service: serviceName });\n        } catch (error) {\n            console.log(`Primary service failed, using fallback for ${serviceName}`);\n            return await fallbackFn();\n        }\n    }\n\n    /**\n     * Simple health check\n     */\n    getHealthStatus() {\n        const metrics = this.getMetrics();\n        const errorSummary = this.errorHandler.getErrorSummary();\n        \n        // Simple health determination\n        let status = 'healthy';\n        \n        if (metrics.successRate < 90 && metrics.calls > 10) {\n            status = 'degraded';\n        }\n        \n        if (metrics.successRate < 50 && metrics.calls > 5) {\n            status = 'unhealthy';\n        }\n        \n        // Check circuit breakers\n        const openCircuits = Object.values(errorSummary.circuitBreakers)\n            .filter(cb => cb.state === 'open').length;\n        \n        if (openCircuits > 0) {\n            status = 'degraded';\n        }\n        \n        return {\n            status,\n            metrics: {\n                successRate: metrics.successRate,\n                totalCalls: metrics.calls,\n                openCircuits\n            },\n            timestamp: new Date().toISOString()\n        };\n    }\n}\n\n// Export singleton instance\nmodule.exports = new ServiceWrapper();"