/**\n * YouTube Automation Platform - Experiment Metrics Collector\n * \n * Advanced metrics collection and analysis system for A/B testing experiments.\n * Provides real-time metrics tracking, conversion funnel analysis, and\n * statistical significance monitoring.\n * \n * Features:\n * - Real-time metrics collection and aggregation\n * - Multi-dimensional metric tracking (conversion, engagement, revenue)\n * - Conversion funnel analysis\n * - Cohort analysis and retention tracking\n * - Statistical significance monitoring\n * - Custom event tracking and attribution\n * \n * @fileoverview Provides comprehensive experiment metrics collection\n * @author YouTube Automation Platform Team\n * @version 2.1.0\n * @since 2025-10-06\n */\n\nconst ConfigurationManager = require('./ConfigurationManager');\n\nclass ExperimentMetricsCollector {\n    constructor(options = {}) {\n        this.region = options.region || process.env.AWS_REGION || 'us-east-1';\n        this.environment = options.environment || process.env.ENVIRONMENT || 'production';\n        \n        // Initialize configuration manager\n        this.configManager = options.configManager || new ConfigurationManager({\n            region: this.region,\n            environment: this.environment\n        });\n        \n        // Metrics storage\n        this.metricsBuffer = new Map(); // Real-time buffer\n        this.aggregatedMetrics = new Map(); // Aggregated metrics\n        this.conversionFunnels = new Map(); // Funnel tracking\n        \n        // Configuration\n        this.bufferFlushInterval = options.bufferFlushInterval || 60000; // 1 minute\n        this.metricsRetention = options.metricsRetention || 90 * 24 * 60 * 60 * 1000; // 90 days\n        \n        // Metric definitions\n        this.metricDefinitions = {\n            // Primary metrics\n            conversion_rate: {\n                type: 'rate',\n                numerator: 'conversions',\n                denominator: 'total_users',\n                description: 'Percentage of users who converted'\n            },\n            engagement_rate: {\n                type: 'rate',\n                numerator: 'engaged_users',\n                denominator: 'total_users',\n                description: 'Percentage of users who engaged'\n            },\n            completion_rate: {\n                type: 'rate',\n                numerator: 'completions',\n                denominator: 'total_users',\n                description: 'Percentage of users who completed the flow'\n            },\n            \n            // Value metrics\n            average_revenue_per_user: {\n                type: 'average',\n                numerator: 'total_revenue',\n                denominator: 'total_users',\n                description: 'Average revenue generated per user'\n            },\n            average_session_duration: {\n                type: 'average',\n                numerator: 'total_session_time',\n                denominator: 'total_sessions',\n                description: 'Average session duration'\n            },\n            \n            // Count metrics\n            total_users: {\n                type: 'count',\n                description: 'Total number of unique users'\n            },\n            total_sessions: {\n                type: 'count',\n                description: 'Total number of sessions'\n            },\n            total_events: {\n                type: 'count',\n                description: 'Total number of events'\n            }\n        };\n        \n        // Start metrics processing\n        this.startMetricsProcessing();\n        \n        console.log(`ExperimentMetricsCollector initialized for environment: ${this.environment}`);\n    }\n\n    /**\n     * Track an experiment event\n     * \n     * @param {Object} event - Event data\n     */\n    async trackEvent(event) {\n        try {\n            const normalizedEvent = this.normalizeEvent(event);\n            \n            // Add to buffer\n            const bufferKey = `${normalizedEvent.experimentId}_${normalizedEvent.variant}`;\n            if (!this.metricsBuffer.has(bufferKey)) {\n                this.metricsBuffer.set(bufferKey, []);\n            }\n            \n            this.metricsBuffer.get(bufferKey).push(normalizedEvent);\n            \n            // Update real-time aggregations\n            await this.updateRealTimeMetrics(normalizedEvent);\n            \n            // Track conversion funnel if applicable\n            if (normalizedEvent.funnelStep) {\n                await this.trackFunnelStep(normalizedEvent);\n            }\n            \n        } catch (error) {\n            console.error('Failed to track experiment event:', error);\n        }\n    }\n\n    /**\n     * Get experiment metrics\n     * \n     * @param {string} experimentId - Experiment ID\n     * @param {Object} options - Query options\n     * @returns {Promise<Object>} Experiment metrics\n     */\n    async getExperimentMetrics(experimentId, options = {}) {\n        try {\n            const timeRange = options.timeRange || 'all';\n            const includeRealTime = options.includeRealTime !== false;\n            \n            // Get aggregated metrics\n            const aggregated = await this.getAggregatedMetrics(experimentId, timeRange);\n            \n            // Add real-time metrics if requested\n            if (includeRealTime) {\n                const realTime = await this.getRealTimeMetrics(experimentId);\n                this.mergeMetrics(aggregated, realTime);\n            }\n            \n            // Calculate derived metrics\n            const derived = this.calculateDerivedMetrics(aggregated);\n            \n            // Get funnel metrics\n            const funnels = await this.getFunnelMetrics(experimentId);\n            \n            return {\n                experimentId,\n                timeRange,\n                generatedAt: new Date().toISOString(),\n                variants: aggregated,\n                derived,\n                funnels,\n                summary: this.generateMetricsSummary(aggregated, derived)\n            };\n            \n        } catch (error) {\n            console.error(`Failed to get experiment metrics for ${experimentId}:`, error);\n            throw error;\n        }\n    }\n\n    /**\n     * Get real-time experiment metrics\n     * \n     * @param {string} experimentId - Experiment ID\n     * @returns {Promise<Object>} Real-time metrics\n     */\n    async getRealTimeMetrics(experimentId) {\n        const realTimeMetrics = {};\n        \n        // Process buffer for this experiment\n        for (const [bufferKey, events] of this.metricsBuffer) {\n            if (bufferKey.startsWith(experimentId)) {\n                const variant = bufferKey.split('_').slice(1).join('_');\n                \n                if (!realTimeMetrics[variant]) {\n                    realTimeMetrics[variant] = this.initializeVariantMetrics();\n                }\n                \n                // Aggregate events\n                events.forEach(event => {\n                    this.aggregateEvent(realTimeMetrics[variant], event);\n                });\n            }\n        }\n        \n        return realTimeMetrics;\n    }\n\n    /**\n     * Calculate statistical significance for metrics\n     * \n     * @param {string} experimentId - Experiment ID\n     * @param {string} metric - Metric name\n     * @returns {Promise<Object>} Statistical significance results\n     */\n    async calculateMetricSignificance(experimentId, metric = 'conversion_rate') {\n        try {\n            const metrics = await this.getExperimentMetrics(experimentId);\n            const variants = Object.keys(metrics.variants);\n            \n            if (variants.length < 2) {\n                return { error: 'Need at least 2 variants for significance testing' };\n            }\n            \n            const results = {};\n            \n            // Calculate pairwise significance\n            for (let i = 0; i < variants.length; i++) {\n                for (let j = i + 1; j < variants.length; j++) {\n                    const variantA = variants[i];\n                    const variantB = variants[j];\n                    \n                    const pairKey = `${variantA}_vs_${variantB}`;\n                    results[pairKey] = this.calculatePairwiseSignificance(\n                        metrics.variants[variantA],\n                        metrics.variants[variantB],\n                        metric\n                    );\n                }\n            }\n            \n            return {\n                experimentId,\n                metric,\n                results,\n                calculatedAt: new Date().toISOString()\n            };\n            \n        } catch (error) {\n            console.error(`Failed to calculate metric significance for ${experimentId}:`, error);\n            throw error;\n        }\n    }\n\n    /**\n     * Get conversion funnel analysis\n     * \n     * @param {string} experimentId - Experiment ID\n     * @returns {Promise<Object>} Funnel analysis\n     */\n    async getFunnelAnalysis(experimentId) {\n        try {\n            const funnelData = this.conversionFunnels.get(experimentId) || {};\n            const analysis = {\n                experimentId,\n                variants: {},\n                comparison: {}\n            };\n            \n            // Analyze each variant's funnel\n            Object.entries(funnelData).forEach(([variant, steps]) => {\n                analysis.variants[variant] = this.analyzeFunnelSteps(steps);\n            });\n            \n            // Compare funnels between variants\n            const variants = Object.keys(analysis.variants);\n            if (variants.length >= 2) {\n                analysis.comparison = this.compareFunnels(analysis.variants);\n            }\n            \n            return analysis;\n            \n        } catch (error) {\n            console.error(`Failed to get funnel analysis for ${experimentId}:`, error);\n            throw error;\n        }\n    }\n\n    /**\n     * Generate experiment report\n     * \n     * @param {string} experimentId - Experiment ID\n     * @param {Object} options - Report options\n     * @returns {Promise<Object>} Comprehensive experiment report\n     */\n    async generateExperimentReport(experimentId, options = {}) {\n        try {\n            const metrics = await this.getExperimentMetrics(experimentId, options);\n            const significance = await this.calculateMetricSignificance(experimentId);\n            const funnelAnalysis = await this.getFunnelAnalysis(experimentId);\n            \n            const report = {\n                experimentId,\n                generatedAt: new Date().toISOString(),\n                \n                // Executive summary\n                summary: {\n                    totalUsers: Object.values(metrics.variants)\n                        .reduce((sum, variant) => sum + (variant.total_users || 0), 0),\n                    totalConversions: Object.values(metrics.variants)\n                        .reduce((sum, variant) => sum + (variant.conversions || 0), 0),\n                    overallConversionRate: this.calculateOverallConversionRate(metrics.variants),\n                    hasSignificantResult: this.hasSignificantResults(significance.results),\n                    recommendedAction: this.getRecommendedAction(significance.results)\n                },\n                \n                // Detailed metrics\n                metrics,\n                \n                // Statistical analysis\n                significance,\n                \n                // Funnel analysis\n                funnelAnalysis,\n                \n                // Performance insights\n                insights: this.generateInsights(metrics, significance, funnelAnalysis),\n                \n                // Recommendations\n                recommendations: this.generateRecommendations(metrics, significance)\n            };\n            \n            return report;\n            \n        } catch (error) {\n            console.error(`Failed to generate experiment report for ${experimentId}:`, error);\n            throw error;\n        }\n    }\n\n    /**\n     * Normalize event data\n     * \n     * @param {Object} event - Raw event data\n     * @returns {Object} Normalized event\n     */\n    normalizeEvent(event) {\n        return {\n            experimentId: event.experimentId,\n            userId: event.userId,\n            variant: event.variant,\n            eventType: event.eventType,\n            timestamp: event.timestamp || new Date().toISOString(),\n            \n            // Event-specific data\n            value: event.value || 0,\n            revenue: event.revenue || 0,\n            duration: event.duration || 0,\n            \n            // Funnel tracking\n            funnelStep: event.funnelStep || null,\n            \n            // Custom properties\n            properties: event.properties || {},\n            \n            // Session information\n            sessionId: event.sessionId || null,\n            \n            // Attribution\n            source: event.source || 'unknown',\n            medium: event.medium || 'unknown',\n            campaign: event.campaign || null\n        };\n    }\n\n    /**\n     * Update real-time metrics\n     * \n     * @param {Object} event - Normalized event\n     */\n    async updateRealTimeMetrics(event) {\n        const key = `${event.experimentId}_${event.variant}`;\n        \n        if (!this.aggregatedMetrics.has(key)) {\n            this.aggregatedMetrics.set(key, this.initializeVariantMetrics());\n        }\n        \n        const metrics = this.aggregatedMetrics.get(key);\n        this.aggregateEvent(metrics, event);\n    }\n\n    /**\n     * Initialize variant metrics structure\n     * \n     * @returns {Object} Initialized metrics\n     */\n    initializeVariantMetrics() {\n        return {\n            // User metrics\n            total_users: 0,\n            unique_users: new Set(),\n            \n            // Conversion metrics\n            conversions: 0,\n            conversion_events: [],\n            \n            // Engagement metrics\n            engaged_users: 0,\n            total_sessions: 0,\n            total_events: 0,\n            \n            // Value metrics\n            total_revenue: 0,\n            total_session_time: 0,\n            \n            // Completion metrics\n            completions: 0,\n            \n            // Time-based metrics\n            first_event: null,\n            last_event: null,\n            \n            // Event breakdown\n            event_types: {},\n            \n            // Cohort data\n            daily_cohorts: {},\n            weekly_cohorts: {}\n        };\n    }\n\n    /**\n     * Aggregate event into metrics\n     * \n     * @param {Object} metrics - Variant metrics\n     * @param {Object} event - Event to aggregate\n     */\n    aggregateEvent(metrics, event) {\n        // Update user metrics\n        if (!metrics.unique_users.has(event.userId)) {\n            metrics.unique_users.add(event.userId);\n            metrics.total_users++;\n        }\n        \n        // Update event counts\n        metrics.total_events++;\n        \n        // Update event type breakdown\n        if (!metrics.event_types[event.eventType]) {\n            metrics.event_types[event.eventType] = 0;\n        }\n        metrics.event_types[event.eventType]++;\n        \n        // Handle specific event types\n        switch (event.eventType) {\n            case 'conversion':\n                metrics.conversions++;\n                metrics.conversion_events.push({\n                    userId: event.userId,\n                    timestamp: event.timestamp,\n                    value: event.value\n                });\n                break;\n                \n            case 'engagement':\n                metrics.engaged_users++;\n                break;\n                \n            case 'completion':\n                metrics.completions++;\n                break;\n                \n            case 'session_start':\n                metrics.total_sessions++;\n                break;\n        }\n        \n        // Update value metrics\n        if (event.revenue > 0) {\n            metrics.total_revenue += event.revenue;\n        }\n        \n        if (event.duration > 0) {\n            metrics.total_session_time += event.duration;\n        }\n        \n        // Update time bounds\n        if (!metrics.first_event || event.timestamp < metrics.first_event) {\n            metrics.first_event = event.timestamp;\n        }\n        \n        if (!metrics.last_event || event.timestamp > metrics.last_event) {\n            metrics.last_event = event.timestamp;\n        }\n        \n        // Update cohort data\n        const eventDate = new Date(event.timestamp);\n        const dayKey = eventDate.toISOString().split('T')[0];\n        \n        if (!metrics.daily_cohorts[dayKey]) {\n            metrics.daily_cohorts[dayKey] = new Set();\n        }\n        metrics.daily_cohorts[dayKey].add(event.userId);\n    }\n\n    /**\n     * Track funnel step\n     * \n     * @param {Object} event - Event with funnel step\n     */\n    async trackFunnelStep(event) {\n        const funnelKey = event.experimentId;\n        \n        if (!this.conversionFunnels.has(funnelKey)) {\n            this.conversionFunnels.set(funnelKey, {});\n        }\n        \n        const funnels = this.conversionFunnels.get(funnelKey);\n        \n        if (!funnels[event.variant]) {\n            funnels[event.variant] = {};\n        }\n        \n        const variantFunnel = funnels[event.variant];\n        \n        if (!variantFunnel[event.funnelStep]) {\n            variantFunnel[event.funnelStep] = {\n                users: new Set(),\n                events: [],\n                firstSeen: event.timestamp\n            };\n        }\n        \n        variantFunnel[event.funnelStep].users.add(event.userId);\n        variantFunnel[event.funnelStep].events.push({\n            userId: event.userId,\n            timestamp: event.timestamp,\n            properties: event.properties\n        });\n    }\n\n    /**\n     * Calculate derived metrics\n     * \n     * @param {Object} variants - Variant metrics\n     * @returns {Object} Derived metrics\n     */\n    calculateDerivedMetrics(variants) {\n        const derived = {};\n        \n        Object.entries(variants).forEach(([variant, metrics]) => {\n            derived[variant] = {};\n            \n            // Calculate rates\n            Object.entries(this.metricDefinitions).forEach(([metricName, definition]) => {\n                if (definition.type === 'rate') {\n                    const numerator = metrics[definition.numerator] || 0;\n                    const denominator = metrics[definition.denominator] || 0;\n                    derived[variant][metricName] = denominator > 0 ? numerator / denominator : 0;\n                } else if (definition.type === 'average') {\n                    const numerator = metrics[definition.numerator] || 0;\n                    const denominator = metrics[definition.denominator] || 0;\n                    derived[variant][metricName] = denominator > 0 ? numerator / denominator : 0;\n                }\n            });\n            \n            // Calculate additional derived metrics\n            derived[variant].events_per_user = metrics.total_users > 0 ? \n                metrics.total_events / metrics.total_users : 0;\n            \n            derived[variant].sessions_per_user = metrics.total_users > 0 ? \n                metrics.total_sessions / metrics.total_users : 0;\n        });\n        \n        return derived;\n    }\n\n    /**\n     * Start metrics processing\n     */\n    startMetricsProcessing() {\n        // Flush buffer periodically\n        setInterval(() => {\n            this.flushMetricsBuffer();\n        }, this.bufferFlushInterval);\n        \n        // Clean up old metrics\n        setInterval(() => {\n            this.cleanupOldMetrics();\n        }, 24 * 60 * 60 * 1000); // Daily cleanup\n        \n        console.log('Started metrics processing');\n    }\n\n    /**\n     * Flush metrics buffer\n     */\n    flushMetricsBuffer() {\n        // In production, this would persist metrics to database\n        const totalEvents = Array.from(this.metricsBuffer.values())\n            .reduce((sum, events) => sum + events.length, 0);\n        \n        if (totalEvents > 0) {\n            console.log(`Flushed ${totalEvents} events from metrics buffer`);\n            // Clear buffer after flush\n            this.metricsBuffer.clear();\n        }\n    }\n\n    /**\n     * Clean up old metrics\n     */\n    cleanupOldMetrics() {\n        const cutoffTime = Date.now() - this.metricsRetention;\n        let cleanedCount = 0;\n        \n        // Clean up aggregated metrics older than retention period\n        for (const [key, metrics] of this.aggregatedMetrics) {\n            if (metrics.last_event && new Date(metrics.last_event).getTime() < cutoffTime) {\n                this.aggregatedMetrics.delete(key);\n                cleanedCount++;\n            }\n        }\n        \n        if (cleanedCount > 0) {\n            console.log(`Cleaned up ${cleanedCount} old metric entries`);\n        }\n    }\n\n    /**\n     * Generate insights from metrics\n     * \n     * @param {Object} metrics - Experiment metrics\n     * @param {Object} significance - Statistical significance\n     * @param {Object} funnelAnalysis - Funnel analysis\n     * @returns {Array} Generated insights\n     */\n    generateInsights(metrics, significance, funnelAnalysis) {\n        const insights = [];\n        \n        // Traffic distribution insights\n        const variants = Object.keys(metrics.variants);\n        const totalUsers = Object.values(metrics.variants)\n            .reduce((sum, variant) => sum + (variant.total_users || 0), 0);\n        \n        variants.forEach(variant => {\n            const variantUsers = metrics.variants[variant].total_users || 0;\n            const percentage = totalUsers > 0 ? (variantUsers / totalUsers) * 100 : 0;\n            \n            if (Math.abs(percentage - (100 / variants.length)) > 5) {\n                insights.push({\n                    type: 'traffic_distribution',\n                    severity: 'medium',\n                    message: `${variant} has ${percentage.toFixed(1)}% of traffic (expected: ${(100/variants.length).toFixed(1)}%)`,\n                    variant\n                });\n            }\n        });\n        \n        // Performance insights\n        Object.entries(significance.results || {}).forEach(([comparison, result]) => {\n            if (result.significant) {\n                const effect = (result.effect * 100).toFixed(1);\n                const direction = result.effect > 0 ? 'increase' : 'decrease';\n                \n                insights.push({\n                    type: 'performance',\n                    severity: 'high',\n                    message: `Significant ${direction} of ${Math.abs(effect)}% detected in ${comparison}`,\n                    comparison,\n                    effect: result.effect\n                });\n            }\n        });\n        \n        return insights;\n    }\n\n    /**\n     * Generate recommendations\n     * \n     * @param {Object} metrics - Experiment metrics\n     * @param {Object} significance - Statistical significance\n     * @returns {Array} Generated recommendations\n     */\n    generateRecommendations(metrics, significance) {\n        const recommendations = [];\n        \n        // Check for clear winners\n        const hasSignificantWinner = Object.values(significance.results || {})\n            .some(result => result.significant && result.effect > 0.05);\n        \n        if (hasSignificantWinner) {\n            recommendations.push({\n                type: 'implementation',\n                priority: 'high',\n                action: 'Implement winning variant',\n                reasoning: 'Statistically significant improvement detected'\n            });\n        } else {\n            recommendations.push({\n                type: 'continuation',\n                priority: 'medium',\n                action: 'Continue experiment',\n                reasoning: 'No significant results yet, need more data'\n            });\n        }\n        \n        return recommendations;\n    }\n\n    // Additional utility methods for statistical calculations\n    calculatePairwiseSignificance(variantA, variantB, metric) {\n        // Implementation would depend on metric type\n        // This is a simplified version\n        const rateA = variantA[metric] || 0;\n        const rateB = variantB[metric] || 0;\n        const nA = variantA.total_users || 0;\n        const nB = variantB.total_users || 0;\n        \n        if (nA < 30 || nB < 30) {\n            return {\n                significant: false,\n                reason: 'insufficient_sample_size',\n                effect: rateB - rateA\n            };\n        }\n        \n        // Simplified significance test\n        const pooledRate = (rateA * nA + rateB * nB) / (nA + nB);\n        const standardError = Math.sqrt(pooledRate * (1 - pooledRate) * (1/nA + 1/nB));\n        \n        if (standardError === 0) {\n            return {\n                significant: false,\n                reason: 'zero_variance',\n                effect: rateB - rateA\n            };\n        }\n        \n        const zScore = (rateB - rateA) / standardError;\n        const pValue = 2 * (1 - this.normalCDF(Math.abs(zScore)));\n        \n        return {\n            significant: pValue < 0.05,\n            pValue,\n            zScore,\n            effect: rateB - rateA,\n            sampleSizes: { variantA: nA, variantB: nB }\n        };\n    }\n\n    normalCDF(x) {\n        return 0.5 * (1 + this.erf(x / Math.sqrt(2)));\n    }\n\n    erf(x) {\n        const a1 =  0.254829592;\n        const a2 = -0.284496736;\n        const a3 =  1.421413741;\n        const a4 = -1.453152027;\n        const a5 =  1.061405429;\n        const p  =  0.3275911;\n        \n        const sign = x >= 0 ? 1 : -1;\n        x = Math.abs(x);\n        \n        const t = 1.0 / (1.0 + p * x);\n        const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);\n        \n        return sign * y;\n    }\n\n    // Placeholder methods for complex calculations\n    async getAggregatedMetrics(experimentId, timeRange) {\n        // In production, this would query from database\n        return {};\n    }\n\n    mergeMetrics(aggregated, realTime) {\n        // Merge real-time metrics with aggregated metrics\n        Object.entries(realTime).forEach(([variant, metrics]) => {\n            if (!aggregated[variant]) {\n                aggregated[variant] = metrics;\n            } else {\n                // Merge logic here\n                Object.entries(metrics).forEach(([key, value]) => {\n                    if (typeof value === 'number') {\n                        aggregated[variant][key] = (aggregated[variant][key] || 0) + value;\n                    }\n                });\n            }\n        });\n    }\n\n    generateMetricsSummary(aggregated, derived) {\n        return {\n            totalVariants: Object.keys(aggregated).length,\n            totalUsers: Object.values(aggregated).reduce((sum, v) => sum + (v.total_users || 0), 0),\n            overallConversionRate: this.calculateOverallConversionRate(aggregated)\n        };\n    }\n\n    calculateOverallConversionRate(variants) {\n        const totalUsers = Object.values(variants).reduce((sum, v) => sum + (v.total_users || 0), 0);\n        const totalConversions = Object.values(variants).reduce((sum, v) => sum + (v.conversions || 0), 0);\n        return totalUsers > 0 ? totalConversions / totalUsers : 0;\n    }\n\n    hasSignificantResults(results) {\n        return Object.values(results || {}).some(result => result.significant);\n    }\n\n    getRecommendedAction(results) {\n        if (this.hasSignificantResults(results)) {\n            return 'implement_winner';\n        }\n        return 'continue_experiment';\n    }\n\n    async getFunnelMetrics(experimentId) {\n        return this.conversionFunnels.get(experimentId) || {};\n    }\n\n    analyzeFunnelSteps(steps) {\n        const analysis = {\n            totalSteps: Object.keys(steps).length,\n            stepConversions: {},\n            dropoffRates: {}\n        };\n        \n        const stepNames = Object.keys(steps).sort();\n        let previousUsers = 0;\n        \n        stepNames.forEach((stepName, index) => {\n            const stepUsers = steps[stepName].users.size;\n            analysis.stepConversions[stepName] = stepUsers;\n            \n            if (index > 0) {\n                const dropoff = previousUsers > 0 ? (previousUsers - stepUsers) / previousUsers : 0;\n                analysis.dropoffRates[stepName] = dropoff;\n            }\n            \n            previousUsers = stepUsers;\n        });\n        \n        return analysis;\n    }\n\n    compareFunnels(variants) {\n        // Compare funnel performance between variants\n        return {\n            bestPerforming: null,\n            worstPerforming: null,\n            significantDifferences: []\n        };\n    }\n}\n\nmodule.exports = ExperimentMetricsCollector;"