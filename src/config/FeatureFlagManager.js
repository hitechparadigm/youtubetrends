/**\n * YouTube Automation Platform - Feature Flag Manager\n * \n * Comprehensive feature flag management system with runtime control,\n * percentage-based rollouts, user targeting, and environment overrides.\n */\n\nconst ConfigurationManager = require('./ConfigurationManager');\nconst crypto = require('crypto');\n\nclass FeatureFlagManager {\n    constructor(options = {}) {\n        this.region = options.region || process.env.AWS_REGION || 'us-east-1';\n        this.environment = options.environment || process.env.ENVIRONMENT || 'production';\n        \n        this.configManager = options.configManager || new ConfigurationManager({\n            region: this.region,\n            environment: this.environment\n        });\n        \n        this.flagCache = new Map();\n        this.userAssignmentCache = new Map();\n        this.cacheTTL = options.cacheTTL || 300000;\n        \n        this.flagMetrics = {\n            totalFlags: 0,\n            activeFlags: 0,\n            flagEvaluations: 0,\n            flagUsage: new Map(),\n            rolloutMetrics: new Map()\n        };\n        \n        this.initializeDefaultFlags();\n        \n        console.log(`FeatureFlagManager initialized for environment: ${this.environment}`);\n    }\n\n    async isEnabled(flagName, userContext = {}) {\n        try {\n            this.flagMetrics.flagEvaluations++;\n            this.trackFlagUsage(flagName);\n            \n            const flagConfig = await this.getFlagConfiguration(flagName);\n            \n            if (!flagConfig) {\n                console.warn(`Feature flag not found: ${flagName}`);\n                return false;\n            }\n            \n            if (!flagConfig.enabled) {\n                return false;\n            }\n            \n            const environmentOverride = await this.checkEnvironmentOverride(flagName, flagConfig);\n            if (environmentOverride !== null) {\n                return environmentOverride;\n            }\n            \n            const targetingResult = await this.evaluateUserTargeting(flagConfig, userContext);\n            if (targetingResult !== null) {\n                return targetingResult;\n            }\n            \n            const rolloutResult = await this.evaluatePercentageRollout(flagConfig, userContext);\n            \n            this.trackRolloutMetrics(flagName, rolloutResult, userContext);\n            \n            return rolloutResult;\n            \n        } catch (error) {\n            console.error(`Feature flag evaluation failed for ${flagName}:`, error);\n            return false;\n        }\n    }\n\n    async getValue(flagName, userContext = {}, defaultValue = false) {\n        try {\n            const flagConfig = await this.getFlagConfiguration(flagName);\n            \n            if (!flagConfig) {\n                return defaultValue;\n            }\n            \n            const isEnabled = await this.isEnabled(flagName, userContext);\n            \n            if (!isEnabled) {\n                return flagConfig.defaultValue !== undefined ? flagConfig.defaultValue : defaultValue;\n            }\n            \n            if (flagConfig.variants && userContext.userId) {\n                const variantKey = await this.getUserVariant(flagName, userContext.userId, flagConfig.variants);\n                return flagConfig.variants[variantKey] || flagConfig.value || true;\n            }\n            \n            return flagConfig.value !== undefined ? flagConfig.value : true;\n            \n        } catch (error) {\n            console.error(`Feature flag value retrieval failed for ${flagName}:`, error);\n            return defaultValue;\n        }\n    }\n\n    async getMultipleFlags(flagNames, userContext = {}) {\n        const results = {};\n        \n        const evaluations = flagNames.map(async (flagName) => {\n            const enabled = await this.isEnabled(flagName, userContext);\n            return { flagName, enabled };\n        });\n        \n        const resolvedEvaluations = await Promise.all(evaluations);\n        \n        for (const { flagName, enabled } of resolvedEvaluations) {\n            results[flagName] = enabled;\n        }\n        \n        return results;\n    }\n\n    async createFlag(flagName, flagConfig) {\n        try {\n            this.validateFlagConfiguration(flagConfig);\n            \n            const currentFlags = await this.configManager.get('features.flags', {});\n            \n            currentFlags[flagName] = {\n                enabled: flagConfig.enabled !== false,\n                rolloutPercentage: flagConfig.rolloutPercentage || 0,\n                value: flagConfig.value,\n                defaultValue: flagConfig.defaultValue,\n                variants: flagConfig.variants || null,\n                targeting: flagConfig.targeting || null,\n                environmentOverrides: flagConfig.environmentOverrides || {},\n                metadata: {\n                    createdAt: flagConfig.metadata?.createdAt || new Date().toISOString(),\n                    updatedAt: new Date().toISOString(),\n                    createdBy: flagConfig.metadata?.createdBy || 'system',\n                    description: flagConfig.metadata?.description || ''\n                }\n            };\n            \n            await this.configManager.set('features.flags', currentFlags);\n            \n            this.flagCache.delete(flagName);\n            \n            console.log(`Feature flag created/updated: ${flagName}`);\n            \n        } catch (error) {\n            console.error(`Failed to create/update feature flag ${flagName}:`, error);\n            throw error;\n        }\n    }\n\n    async deleteFlag(flagName) {\n        try {\n            const currentFlags = await this.configManager.get('features.flags', {});\n            \n            if (currentFlags[flagName]) {\n                delete currentFlags[flagName];\n                await this.configManager.set('features.flags', currentFlags);\n                \n                this.flagCache.delete(flagName);\n                this.userAssignmentCache.delete(flagName);\n                \n                console.log(`Feature flag deleted: ${flagName}`);\n            }\n            \n        } catch (error) {\n            console.error(`Failed to delete feature flag ${flagName}:`, error);\n            throw error;\n        }\n    }\n\n    async updateRolloutPercentage(flagName, percentage) {\n        try {\n            if (percentage < 0 || percentage > 100) {\n                throw new Error('Rollout percentage must be between 0 and 100');\n            }\n            \n            const currentFlags = await this.configManager.get('features.flags', {});\n            \n            if (!currentFlags[flagName]) {\n                throw new Error(`Feature flag not found: ${flagName}`);\n            }\n            \n            currentFlags[flagName].rolloutPercentage = percentage;\n            currentFlags[flagName].metadata.updatedAt = new Date().toISOString();\n            \n            await this.configManager.set('features.flags', currentFlags);\n            \n            this.flagCache.delete(flagName);\n            \n            console.log(`Updated rollout percentage for ${flagName}: ${percentage}%`);\n            \n        } catch (error) {\n            console.error(`Failed to update rollout percentage for ${flagName}:`, error);\n            throw error;\n        }\n    }\n\n    async setFlagEnabled(flagName, enabled) {\n        try {\n            const currentFlags = await this.configManager.get('features.flags', {});\n            \n            if (!currentFlags[flagName]) {\n                throw new Error(`Feature flag not found: ${flagName}`);\n            }\n            \n            currentFlags[flagName].enabled = enabled;\n            currentFlags[flagName].metadata.updatedAt = new Date().toISOString();\n            \n            await this.configManager.set('features.flags', currentFlags);\n            \n            this.flagCache.delete(flagName);\n            \n            console.log(`Feature flag ${flagName} ${enabled ? 'enabled' : 'disabled'}`);\n            \n        } catch (error) {\n            console.error(`Failed to ${enabled ? 'enable' : 'disable'} feature flag ${flagName}:`, error);\n            throw error;\n        }\n    }\n\n    async getAllFlags() {\n        try {\n            return await this.configManager.get('features.flags', {});\n        } catch (error) {\n            console.error('Failed to get all feature flags:', error);\n            return {};\n        }\n    }\n\n    async getFlagConfiguration(flagName) {\n        try {\n            const cacheKey = `flag_${flagName}`;\n            if (this.flagCache.has(cacheKey)) {\n                const cached = this.flagCache.get(cacheKey);\n                if (Date.now() - cached.timestamp < this.cacheTTL) {\n                    return cached.config;\n                }\n            }\n            \n            const allFlags = await this.configManager.get('features.flags', {});\n            const flagConfig = allFlags[flagName];\n            \n            if (flagConfig) {\n                this.flagCache.set(cacheKey, {\n                    config: flagConfig,\n                    timestamp: Date.now()\n                });\n            }\n            \n            return flagConfig || null;\n            \n        } catch (error) {\n            console.error(`Failed to get flag configuration for ${flagName}:`, error);\n            return null;\n        }\n    }\n\n    async checkEnvironmentOverride(flagName, flagConfig) {\n        if (!flagConfig.environmentOverrides) {\n            return null;\n        }\n        \n        const override = flagConfig.environmentOverrides[this.environment];\n        if (override !== undefined) {\n            console.log(`Environment override for ${flagName} in ${this.environment}: ${override}`);\n            return override;\n        }\n        \n        return null;\n    }\n\n    async evaluateUserTargeting(flagConfig, userContext) {\n        if (!flagConfig.targeting || !userContext.userId) {\n            return null;\n        }\n        \n        const targeting = flagConfig.targeting;\n        \n        if (targeting.userIds && targeting.userIds.includes(userContext.userId)) {\n            return true;\n        }\n        \n        if (targeting.excludeUserIds && targeting.excludeUserIds.includes(userContext.userId)) {\n            return false;\n        }\n        \n        if (targeting.attributes) {\n            for (const [attribute, expectedValue] of Object.entries(targeting.attributes)) {\n                const userValue = userContext[attribute];\n                \n                if (Array.isArray(expectedValue)) {\n                    if (!expectedValue.includes(userValue)) {\n                        return false;\n                    }\n                } else if (userValue !== expectedValue) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        \n        return null;\n    }\n\n    async evaluatePercentageRollout(flagConfig, userContext) {\n        const rolloutPercentage = flagConfig.rolloutPercentage || 0;\n        \n        if (rolloutPercentage === 0) {\n            return false;\n        }\n        \n        if (rolloutPercentage >= 100) {\n            return true;\n        }\n        \n        const userId = userContext.userId || userContext.sessionId || 'anonymous';\n        const hash = this.generateConsistentHash(flagConfig.metadata?.createdAt || '', userId);\n        const userPercentile = hash % 100;\n        \n        return userPercentile < rolloutPercentage;\n    }\n\n    async getUserVariant(flagName, userId, variants) {\n        const cacheKey = `variant_${flagName}_${userId}`;\n        \n        if (this.userAssignmentCache.has(cacheKey)) {\n            const cached = this.userAssignmentCache.get(cacheKey);\n            if (Date.now() - cached.timestamp < this.cacheTTL) {\n                return cached.variant;\n            }\n        }\n        \n        const variantKeys = Object.keys(variants);\n        const hash = this.generateConsistentHash(flagName, userId);\n        const variantIndex = hash % variantKeys.length;\n        const selectedVariant = variantKeys[variantIndex];\n        \n        this.userAssignmentCache.set(cacheKey, {\n            variant: selectedVariant,\n            timestamp: Date.now()\n        });\n        \n        return selectedVariant;\n    }\n\n    generateConsistentHash(seed, userId) {\n        const hash = crypto.createHash('md5')\n            .update(seed + userId)\n            .digest('hex');\n        \n        return parseInt(hash.substring(0, 8), 16);\n    }\n\n    validateFlagConfiguration(flagConfig) {\n        if (typeof flagConfig !== 'object') {\n            throw new Error('Flag configuration must be an object');\n        }\n        \n        if (flagConfig.rolloutPercentage !== undefined) {\n            if (typeof flagConfig.rolloutPercentage !== 'number' || \n                flagConfig.rolloutPercentage < 0 || \n                flagConfig.rolloutPercentage > 100) {\n                throw new Error('Rollout percentage must be a number between 0 and 100');\n            }\n        }\n        \n        if (flagConfig.targeting && typeof flagConfig.targeting !== 'object') {\n            throw new Error('Targeting configuration must be an object');\n        }\n        \n        if (flagConfig.variants && typeof flagConfig.variants !== 'object') {\n            throw new Error('Variants configuration must be an object');\n        }\n    }\n\n    async initializeDefaultFlags() {\n        try {\n            const defaultFlags = {\n                'ai-model-fallback': {\n                    enabled: true,\n                    rolloutPercentage: 100,\n                    value: true,\n                    metadata: {\n                        description: 'Enable AI model fallback when primary model fails',\n                        createdAt: new Date().toISOString(),\n                        createdBy: 'system'\n                    }\n                },\n                'enhanced-error-handling': {\n                    enabled: true,\n                    rolloutPercentage: 50,\n                    value: true,\n                    environmentOverrides: {\n                        development: true,\n                        staging: true,\n                        production: false\n                    },\n                    metadata: {\n                        description: 'Enable enhanced error handling and logging',\n                        createdAt: new Date().toISOString(),\n                        createdBy: 'system'\n                    }\n                },\n                'ab-testing-enabled': {\n                    enabled: true,\n                    rolloutPercentage: 80,\n                    value: true,\n                    metadata: {\n                        description: 'Enable A/B testing framework',\n                        createdAt: new Date().toISOString(),\n                        createdBy: 'system'\n                    }\n                },\n                'cost-optimization': {\n                    enabled: true,\n                    rolloutPercentage: 100,\n                    value: true,\n                    variants: {\n                        aggressive: { threshold: 0.05, enabled: true },\n                        moderate: { threshold: 0.10, enabled: true },\n                        conservative: { threshold: 0.15, enabled: false }\n                    },\n                    metadata: {\n                        description: 'Enable cost optimization features',\n                        createdAt: new Date().toISOString(),\n                        createdBy: 'system'\n                    }\n                }\n            };\n            \n            const existingFlags = await this.configManager.get('features.flags', null);\n            if (!existingFlags) {\n                await this.configManager.set('features.flags', defaultFlags);\n                console.log('Initialized default feature flags');\n            }\n            \n        } catch (error) {\n            console.error('Failed to initialize default flags:', error);\n        }\n    }\n\n    trackFlagUsage(flagName) {\n        if (!this.flagMetrics.flagUsage.has(flagName)) {\n            this.flagMetrics.flagUsage.set(flagName, 0);\n        }\n        \n        this.flagMetrics.flagUsage.set(flagName, this.flagMetrics.flagUsage.get(flagName) + 1);\n    }\n\n    trackRolloutMetrics(flagName, enabled, userContext) {\n        if (!this.flagMetrics.rolloutMetrics.has(flagName)) {\n            this.flagMetrics.rolloutMetrics.set(flagName, {\n                totalEvaluations: 0,\n                enabledCount: 0,\n                disabledCount: 0\n            });\n        }\n        \n        const metrics = this.flagMetrics.rolloutMetrics.get(flagName);\n        metrics.totalEvaluations++;\n        \n        if (enabled) {\n            metrics.enabledCount++;\n        } else {\n            metrics.disabledCount++;\n        }\n    }\n\n    getMetrics() {\n        return {\n            ...this.flagMetrics,\n            flagUsage: Object.fromEntries(this.flagMetrics.flagUsage),\n            rolloutMetrics: Object.fromEntries(this.flagMetrics.rolloutMetrics)\n        };\n    }\n\n    clearCache() {\n        this.flagCache.clear();\n        this.userAssignmentCache.clear();\n        console.log('Feature flag caches cleared');\n    }\n}\n\nmodule.exports = FeatureFlagManager;"